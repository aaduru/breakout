{"version":3,"sources":["webpack:///webpack/bootstrap 575833313989134b91b3","webpack:///./breakout.js","webpack:///./game.js","webpack:///./game_view.js","webpack:///./ball.js","webpack:///./bricks.js","webpack:///./paddle.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;ACrCA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;;;;;;ACpBD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA4B,WAAW;AACvC;;AAEA;AACA;AACA;AACA,4BAA2B,WAAW;AACtC;;AAEA;AACA;AACA;AACA,4BAA2B,WAAW;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,eAAe;AAC1C;AACA;AACA,iCAAgC,WAAW;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,WAAW;AAC3C;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA,oBAAmB,mBAAmB;AACtC,uBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;;;;;;;;ACzUA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,qBAAoB,qCAAqC,EAAE;AAC3D;AACA,MAAK;AACL,4BAA2B,cAAc,EAAE;AAC3C;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;AACL;;;AAGA;;AAEA;AACA;AACA;AACA;;;;AAIA;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,gBAAgB;AAChC;AACA,mBAAkB,eAAe;AACjC;AACA,8BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,kBAAkB;AACrC,sBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 575833313989134b91b3","\nconst Game = require(\"./game\");\nconst GameView = require(\"./game_view\");\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const canvasEl = document.getElementsByTagName(\"canvas\")[0];\n  canvasEl.width = Game.DIM_X;\n  canvasEl.height = Game.DIM_Y;\n\n  const ctx = canvasEl.getContext(\"2d\");\n  const game = new Game(ctx,Game.DIM_X,Game.DIM_Y );\n  const gameView = new GameView(game, ctx);\n  document.addEventListener(\"keyup\", (e) => {\n    if(e.keyCode == 32 ) {\n      // && !game.inPlay\n      // game.inPlay = true;\n      // console.log(game.inPlay);\n      gameView.start();\n    }\n  });\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./breakout.js\n// module id = 0\n// module chunks = 0","const Ball = require(\"./ball.js\");\nconst Brick = require(\"./bricks.js\");\nconst Paddle = require(\"./paddle.js\");\n\nclass Game {\n  constructor(ctx) {\n    this.ctx = ctx;\n    this.dx = 1;\n    this.dy = -1;\n    this.paddleWidth = 100;\n    this.ball = new Ball(ctx, Game.DIM_X, Game.DIM_Y, this.dx, this.dy, this.paddleWidth);\n    this.paddle = new Paddle(ctx,((Game.DIM_X/2) - (this.paddleWidth/2)), (Game.DIM_Y - 20), this.paddleWidth);\n    this.rows = 1;\n    this.columns = 6;\n    this.brick = new Brick(ctx, this.rows, this.columns);\n\n    this.x = Game.DIM_X / 2;\n    this.y = Game.DIM_Y-30;\n    this.radius = 10;\n\n    this.score = 0 ;\n    this.scorefactor = 100;\n    this.lives = 3;\n    this.level = 1 ;\n    this.maxlevel = 4;\n\n    this.isOver = false;\n\n    this.noOfBricks = 6;\n    this.brickWidth = ((Game.DIM_X - 7) / this.noOfBricks) ;\n    this.brickHeight = 15;\n    this.brickPadding = 1;\n    this.brickTopPadding = 50;\n    this.brickLeftPadding = 1;\n    this.count = this.noOfBricks;\n\n    this.inPlay = false;\n    this.collision = false;\n  }\n\n  drawScore(ctx){\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 10px Gloria Hallelujah';\n    ctx.fillText(`SCORE : ${this.score}`, 20, 30);\n  }\n\n  drawLives(ctx){\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 10px Gloria Hallelujah';\n    ctx.fillText(`Lives: ${this.lives}`, 100, 30);\n  }\n\n  drawLevels(ctx){\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 10px Gloria Hallelujah';\n    ctx.fillText(`Level: ${this.level}`, 250, 30);\n  }\n\n  displayLevel(ctx){\n    ctx.clearRect(0, 0, Game.DIM_X, Game.DIM_Y);\n    ctx.fillStyle = Game.BG_COLOR;\n    ctx.fillRect(0, 0, Game.DIM_X, Game.DIM_Y);\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 24px Gloria Hallelujah';\n    ctx.fillText(`Level: ${this.level + 1}`, 50, 200);\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 24px Gloria Hallelujah';\n    ctx.fillText(`Your Score: ${this.score}`, 150, 250);\n  }\n\n  drawGameOver(ctx){\n    ctx.clearRect(0, 0, Game.DIM_X, Game.DIM_Y);\n    ctx.fillStyle = Game.BG_COLOR;\n    ctx.fillRect(0, 0, Game.DIM_X, Game.DIM_Y);\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 24px Gloria Hallelujah';\n    ctx.fillText(`GAME OVER`, 25, 100);\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 24px Gloria Hallelujah';\n    ctx.fillText(`Your Score: ${this.score}`, 150, 250);\n    this.restart(ctx);\n  }\n  drawGameWon(ctx){\n    ctx.clearRect(0, 0, Game.DIM_X, Game.DIM_Y);\n    ctx.fillStyle = Game.BG_COLOR;\n    ctx.fillRect(0, 0, Game.DIM_X, Game.DIM_Y);\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 24px Gloria Hallelujah';\n    ctx.fillText(`You have won`, 25, 100);\n    ctx.fillStyle = 'white';\n    ctx.font = 'bold 24px Gloria Hallelujah';\n    ctx.fillText(`Your Score: ${this.score}`, 150, 250);\n    this.restart(ctx);\n  }\n\n\n\n\n  brickBallCollision(){\n    console.log(\"X cord\");\n    console.log(this.ball.x);\n    console.log(\"Y cord\");\n    console.log(this.ball.y);\n    for( let c = 0; c < this.columns ; c++ ){\n      for ( let r = 0; r < this.rows; r++){\n        // the position of ball is greater than the position of brick\n        // if (this.brick.bricks[c][r].alive === 1) {\n        //   // console.log(this.brick.bricks[c][r]);\n        //   if ((this.ball.x - this.radius) > (this.brick.bricks[c][r].x - this.brickWidth) ) {\n        //     if ( (this.ball.y + this.radius) >= (this.brick.bricks[c][r].y - this.brickHeight)){\n        //       //should check for position of ball being less than that of brick\n        //       //here i need to width of the brick to the x position of brick as the ball can hit any part of the width\n        //       if((this.ball.x + this.radius) <= (this.brick.bricks[c][r].x + this.brickWidth)) {\n        //         // i  need to check if i need to add height as well\n        //         if((this.ball.y - this.radius) <= (this.brick.bricks[c][r].y + this.brickHeight)){\n        //           // make the brick disappear\n        //           // need to change the direction of the ball\n        //           this.ball.movey = - this.ball.movey;\n        //           this.score += this.scorefactor;\n        //           this.brick.bricks[c][r].alive = -1;\n        //           this.count --;\n        //         }\n        //       }\n        //     }\n        //   }\n        // }\n        if (this.brick.bricks[c][r].alive === 1) {\n          //Check bottom collision\n          // debugger\n          this.collision = false;\n          if( ((this.brick.bricks[c][r].x - (this.radius/1.44)) <= this.ball.x) && (this.brick.bricks[c][r].x + this.brickWidth + (this.radius/1.44) >= this.ball.x)) {\n          //  if((this.ball.y-this.radius) === (this.brick.bricks[c][r].y+this.brickHeight)){\n            if((this.ball.y-this.radius) > (this.brick.bricks[c][r].y+this.brickHeight-Math.abs(this.ball.movey))){\n              if((this.ball.y-this.radius) < (this.brick.bricks[c][r].y+this.brickHeight+Math.abs(this.ball.movey))){\n                this.collision = true;\n                this.ball.movey = - this.ball.movey;\n                console.log(\"Bottom Collison\");\n              }\n            }\n          }\n          //Check top collision\n          if( ((this.brick.bricks[c][r].x - (this.radius/1.44)) <= this.ball.x) && (this.brick.bricks[c][r].x + this.brickWidth + (this.radius/1.44) >= this.ball.x)) {\n            //if((this.ball.y+this.radius) === (this.brick.bricks[c][r].y)){\n            if((this.ball.y+this.radius) > (this.brick.bricks[c][r].y-Math.abs(this.ball.movey))){\n              if((this.ball.y+this.radius) < (this.brick.bricks[c][r].y+Math.abs(this.ball.movey))){\n                this.collision = true;\n                this.ball.movey = - this.ball.movey;\n                console.log(\"Top Collison\");\n              }\n            }\n          }\n          //Check left collision\n          if( ((this.brick.bricks[c][r].y + this.brickHeight + (this.radius/1.44)) >= this.ball.y) && ((this.brick.bricks[c][r].y - (this.radius/1.44) <= this.ball.y))) {\n            //if((this.ball.x+this.radius) === Math.round(this.brick.bricks[c][r].x)){\n            if((this.ball.x+this.radius) > Math.round(this.brick.bricks[c][r].x-Math.abs(this.ball.movex))){\n              if((this.ball.x+this.radius) < Math.round(this.brick.bricks[c][r].x+Math.abs(this.ball.movex))){\n                this.collision = true;\n                this.ball.movex = - this.ball.movex;\n                console.log(\"left Collison\");\n              }\n            }\n          }\n          //Check right collision\n          if( ((this.brick.bricks[c][r].y + this.brickHeight + (this.radius/1.44)) >= this.ball.y) && ((this.brick.bricks[c][r].y - (this.radius/1.44) <= this.ball.y))) {\n            //debugger\n            //if((this.ball.x-this.radius) === Math.round(this.brick.bricks[c][r].x+this.brickWidth)){\n            if((this.ball.x-this.radius) > Math.round(this.brick.bricks[c][r].x+this.brickWidth-Math.abs(this.ball.movex))){\n              if((this.ball.x-this.radius) < Math.round(this.brick.bricks[c][r].x+this.brickWidth+Math.abs(this.ball.movex))){\n                this.collision = true;\n                this.ball.movex = - this.ball.movex;\n                console.log(\"Right Collison\");\n              }\n            }\n          }\n          if(this.collision) {\n            this.score += this.scorefactor;\n            this.brick.bricks[c][r].alive = -1;\n            this.count --;\n            this.collision = false;\n          }\n        }\n      }\n    }\n  }\n\n  won(ctx){\n    if (this.level === 3 && this.count === 0){\n      this.drawGameWon(ctx);\n    }\n  }\n  nextLevel(ctx){\n    if (this.count === 0) {\n      this.displayLevel(ctx);\n      if (this.level < this.maxlevel ){\n        // TODO: refactor to not rely on window\n        clearInterval(window.interval);\n        this.level++;\n        this.brick.bricks = [];\n        this.brick = null;\n        delete this.brick;\n        this.ball = null;\n        delete this.ball;\n        this.paddle = null;\n        delete this.paddle;\n        this.rows ++;\n        this.columns ++;\n        this.dx ++;\n        this.dy --;\n        this.paddleWidth  = this.paddleWidth - 20;\n        this.noOfBricks  ++;\n        this.brickWidth = ((Game.DIM_X - 7) / this.noOfBricks) ;\n        this.brickHeight = 15;\n        this.brickPadding = 1;\n        this.brickTopPadding = 50;\n        this.brickLeftPadding = 1;\n\n        this.count = (this.rows * this.noOfBricks);\n        this.ball = new Ball(ctx, Game.DIM_X, Game.DIM_Y, this.dx, this.dy, this.paddleWidth);\n        this.paddle = new Paddle(ctx, ((Game.DIM_X/2) - (this.paddleWidth/2)), (Game.DIM_Y - 20), this.paddleWidth);\n        this.brick = new Brick(ctx, this.rows, this.columns);\n        this.brick.drawBricks(this.brickWidth, this.brickHeight, this.brickPadding, this.brickTopPadding, this.brickLeftPadding);\n        this.ball.x = Game.DIM_X / 2;\n        this.ball.y = Game.DIM_Y - 30;\n        this.paddle.x = (Game.DIM_X / 2) - 50;\n        this.paddle.y = Game.DIM_Y - 20;\n        this.paddle.displayPaddle();\n        this.ball.displayBall();\n        this.ball.ballUpdate(this.paddle.x);\n\n      }\n\n    }\n  }\n\n  draw(ctx) {\n    ctx.clearRect(0, 0, Game.DIM_X, Game.DIM_Y);\n    ctx.fillStyle = Game.BG_COLOR;\n    ctx.fillRect(0, 0, Game.DIM_X, Game.DIM_Y);\n\n\n    this.ball.displayBall();\n    this.ball.ballUpdate(this.paddle.x);\n\n    if (this.brick.bricks.length === 0 ){\n      this.brick.brickArray();\n    }\n    this.paddle.displayPaddle();\n    this.brick.drawBricks(this.brickWidth, this.brickHeight, this.brickPadding, this.brickTopPadding, this.brickLeftPadding);\n    if ((this.ball.y + this.ball.movey) > (Game.DIM_Y + 20)) {\n      this.gameResetForLives(ctx);\n    }\n    this.brickBallCollision();\n    this.drawScore(ctx);\n    this.drawLives(ctx);\n    this.drawLevels(ctx);\n    this.gameOver(ctx);\n    this.nextLevel(ctx);\n    this.won(ctx);\n  }\n\n  gameResetForLives(ctx){\n\n    this.lives --;\n\n    this.ball.x = Game.DIM_X / 2;\n    this.ball.y = Game.DIM_Y - 30;\n    this.paddle.x = (Game.DIM_X / 2) - 50;\n    this.paddle.y = Game.DIM_Y - 20;\n\n    this.paddle.displayPaddle();\n    this.ball.displayBall();\n    this.ball.ballUpdate(this.paddle.x);\n  }\n\n  gameOver(ctx){\n    if (this.lives === 0){\n      clearInterval(window.interval);\n      this.drawGameOver(ctx);\n    }\n  }\n\n  restart(ctx) {\n\n    this.rows = 1;\n    this.columns = 6;\n    this.x = Game.DIM_X / 2;\n    this.y = Game.DIM_Y-30;\n    this.dx = 1;\n    this.dy = -1;\n    this.radius = 10;\n\n    this.score = 0 ;\n    this.scorefactor = 100;\n    this.lives = 3;\n    this.level = 1 ;\n    this.maxlevel = 3;\n\n    this.isOver = false;\n    this.paddleWidth = 100;\n    this.noOfBricks = 6;\n    this.count = this.noOfBricks;\n    this.brickWidth = ((Game.DIM_X - 7) / this.noOfBricks) ;\n    this.brickHeight = 15;\n    this.brickPadding = 1;\n    this.brickTopPadding = 50;\n    this.brickLeftPadding = 1;\n    this.brick.bricks = [];\n    this.brick = null;\n    delete this.brick;\n    this.ball = null;\n    delete this.ball;\n    this.paddle = null;\n    delete this.paddle;\n    this.ball = new Ball(ctx, Game.DIM_X, Game.DIM_Y, this.dx, this.dy, this.paddleWidth);\n    this.paddle = new Paddle(ctx, ((Game.DIM_X/2) - (this.paddleWidth/2)), (Game.DIM_Y - 20), this.paddleWidth);\n    this.brick = new Brick(ctx, this.rows, this.columns);\n    this.paddle.x = (Game.DIM_X / 2) - 50;\n    this.paddle.displayPaddle();\n    this.ball.displayBall();\n    this.ball.ballUpdate(this.paddle.x);\n    this.brick.drawBricks(this.brickWidth, this.brickHeight, this.brickPadding, this.brickTopPadding, this.brickLeftPadding);\n  }\n\n\n}\nGame.BG_COLOR = \"#000000\";\nGame.DIM_X = 400;\nGame.DIM_Y = 300;\n\n\nmodule.exports = Game;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./game.js\n// module id = 1\n// module chunks = 0","\nclass GameView {\n  constructor(game, ctx) {\n    this.ctx = ctx;\n    this.game = game;\n    this.game.draw(this.ctx);\n\n  }\n\n  bindKeyHandlers() {\n\n    Object.keys(GameView.MOVES).forEach((k) => {\n      let move = GameView.MOVES[k];\n\n      key(k, () => { this.game.paddle.updatePaddle(move); });\n      // this.game.paddle.updatePaddle(move);\n    });\n    // key(\"space\", () => { this.start(); });\n  }\n\n\n  start() {\n\n    this.bindKeyHandlers();\n    // TODO: refactor to not be on window\n    window.interval = setInterval( () => {\n\n      this.game.draw(this.ctx);\n    },  10);\n  }\n\n\n}\n\nGameView.MOVES = {\n  \"left\": -10,\n  \"right\": 10\n};\n\n\n\nmodule.exports = GameView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./game_view.js\n// module id = 2\n// module chunks = 0","class Ball {\n  constructor(ctx, i, j, dx, dy, pw) {\n    this.ctx = ctx;\n    this.dimX = i;\n    this.dimY = j;\n    this.x = i/2;\n    this.y = j - 30;\n    this.movex = dx;\n    this.movey = -dy;\n    this.reachbottom = false;\n\n    this.paddlew = pw;\n  }\n\n  displayBall() {\n    this.ctx.beginPath();\n    this.ctx.fillStyle=\"white\";\n    this.ctx.arc(this.x,this.y,10,0,Math.PI*2,true);\n    this.ctx.closePath();\n    this.ctx.fill();\n  }\n\n\n  ballUpdate(paddlex){\n\n    if( ( (this.x + this.movex)  < 10) || ( (this.x + this.movex) > (this.dimX - 10) ) ) {\n      this.movex=-this.movex;\n\n    }\n    if( (this.y + this.movey) < 10){\n      this.movey=-this.movey;\n    }\n    if ((this.y + this.movey) > (this.dimY - 30)) {\n      if (this.x > paddlex && this.x < (paddlex + this.paddlew ) ){\n          this.movey= (-1 *this.movey)  ;\n      }\n    }\n    this.x+=this.movex;\n    this.y+=this.movey;\n    if (this.y >= 289) {\n      this.reachbottom = true;\n    }\n  }\n}\n\nmodule.exports = Ball;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./ball.js\n// module id = 3\n// module chunks = 0","class Brick {\n  constructor(ctx, r, c){\n    this.ctx = ctx;\n    this.bricks = [];\n    this.alive = true;\n    this.rows = r ;\n    this.columns = c ;\n\n  }\n  brickArray(){\n    for(let i=0; i<this.columns; i++) {\n      this.bricks[i] = [];\n      for(let j=0; j < this.rows; j++) {\n        // need to have x postion, y postion and alive value for every brick\n        this.bricks[i][j] = { x: 0, y: 0, alive: 1};\n\n      }\n    }\n  }\n  //\n  drawBricks(w,h, p, tp, lp) {\n    if (this.bricks.length === 0) {\n      return;\n    }\n    for (let c = 0; c < this.columns; c++) {\n      for (let r = 0; r < this.rows; r++) {\n        if (this.bricks[c][r].alive > 0) {\n          // set x and y postion of the bricks so that i can use them to keep track of the bricks\n          let brickX = (c * (w + p)) + lp;\n          let brickY = (r * (h + p)) + tp;\n          this.bricks[c][r].x = brickX;\n          this.bricks[c][r].y = brickY;\n          // // console.log(brickX);\n          // // console.log(brickY);\n          // console.log(h);\n          // console.log(p);\n          // console.log(tp);\n          this.ctx.beginPath();\n          this.ctx.rect(brickX, brickY, w, h);\n          this.ctx.fillStyle = \"#841F27\";\n          this.ctx.fill();\n          this.ctx.closePath();\n        }\n      }\n  }\n}\n\n\n}\n\nmodule.exports = Brick;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bricks.js\n// module id = 4\n// module chunks = 0","class  Paddle{\n  constructor(ctx, i , j, pw){\n    this.ctx = ctx;\n    // this.dimX = i;\n    // this.dimY = j;\n    this.x = i;\n    this.y = j;\n    this.paddleWidth = pw;\n  }\n  displayPaddle(){\n\n    this.ctx.beginPath();\n    this.ctx.fillStyle = \"yellow\";\n    this.ctx.rect(this.x, this.y, this.paddleWidth, 20);\n    this.ctx.closePath();\n    this.ctx.fill();\n  }\n\n\n  updatePaddle(move){\n\n    if (move === -10 ){\n      if (this.x > 20){\n          this.x += (-30);\n        // this.x = this.x + 10 ;\n      }\n      else {\n        this.x = 0;\n      }\n    }else if (move === 10){\n      if (this.x < (400-this.paddleWidth-30)){\n          this.x += (30);\n        // this.x = this.x - 10 ;\n      }\n      else {\n          this.x = 400-this.paddleWidth;\n      }\n    }\n  }\n  restart(keys) {\n    if (keys.includes(13)) { // return\n\n      this.isOver = false;\n      this.level = 0;\n      this.score = 0;\n      this.lives = 3;\n\n    }\n  }\n}\n\nmodule.exports = Paddle;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./paddle.js\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}